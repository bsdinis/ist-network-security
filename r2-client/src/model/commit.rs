use super::snapshot::PatchStr;
use super::user::User;
use crate::sigkey::{MaybeSigner, SignatureVerifier};
use chrono::{DateTime, Utc};
use ring::digest;
use serde::{Deserialize, Serialize};

static ID_DIGEST_ALGO: &digest::Algorithm = &digest::SHA512;

/// Unverified or unsigned commit.
///
/// It should always be converted to a [Commit] object by verifying
/// ([`Self::verify()`]) or authoring ([`Self::author()`]) it.
///
/// It cannot be serialized, to avoid persisting bad data, but
/// the serialization format is guaranteed to be compatible with
/// [Commit] (which can be serialized).
#[derive(Deserialize, Clone, Debug, PartialEq)]
pub struct UnsafeCommit {
    pub id: Option<String>,

    pub prev_commit_id: Option<String>,
    pub author_id: Option<String>,
    pub ts: DateTime<Utc>,
    pub message: String,

    pub patch: PatchStr,

    pub signature: Option<Vec<u8>>,

    #[serde(skip)]
    _priv: (),
}

/// A (just-signed or verified) commit.
///
/// Obtained from authoring or verifying an [UnsafeCommit].
///
/// It cannot be deserialized (because we'd get possibly invalid signatures,
/// authors or IDs), but the serialization format is guaranteed to be compatible
/// with [UnsafeCommit] (which can be deserialized).
#[derive(Clone, Serialize)]
pub struct Commit {
    pub id: String,

    pub prev_commit_id: Option<String>,
    pub author_id: String,
    pub ts: DateTime<Utc>,
    pub message: String,

    pub patch: PatchStr,

    pub signature: Vec<u8>,

    #[serde(skip)]
    _priv: (),
}

// TODO: use more specific types everywhere
type Error = Box<dyn std::error::Error>;

impl UnsafeCommit {
    /// Create new comit from previous one, message and patch.
    ///
    /// Timestamp is set to the current system time.
    /// To obtain an ID, set the author field and sign it convert
    /// it to a [Commit] with [`Self::author`].
    pub fn new(prev_commit: Option<&Commit>, message: String, patch: PatchStr) -> Self {
        UnsafeCommit {
            id: None,
            prev_commit_id: prev_commit.map(|c| c.id.clone()),
            author_id: None,
            ts: Utc::now(),
            message,
            patch,
            signature: None,
            _priv: (),
        }
    }

    /// Convert to [Commit], setting the author, generating an ID and signing it.
    ///
    /// Usage with commits that already have a signature, author or ID will panic
    /// in debug builds.
    pub fn author(mut self, author: &User) -> Result<Commit, Error> {
        debug_assert!(self.id.is_none(), "Authoring commit that already has an ID");
        debug_assert!(
            self.author_id.is_none(),
            "Authoring commit that already has an author"
        );
        debug_assert!(
            self.signature.is_none(),
            "Authoring commit that already has a signature"
        );

        self.author_id = Some(author.id.to_owned());
        self.id = Some(self.gen_id());

        let bytes = self.bytes();
        self.signature = Some(author.sign(&bytes)?);

        Ok(Commit {
            id: self.id.unwrap(),
            prev_commit_id: self.prev_commit_id,
            author_id: self.author_id.unwrap(),
            ts: self.ts,
            message: self.message,
            patch: self.patch,
            signature: self.signature.unwrap(),
            _priv: (),
        })
    }

    /// Convert to [Commit] after verification, given its author.
    ///
    /// - Passing an [User] which is not the commit's author will panic;
    /// - A commit whose ID does not match the one generated by our
    ///   algorithm is considered invalid;
    /// - A valid commit must have a valid signature from its author.
    pub fn verify(self, author: &User) -> Result<Commit, Error> {
        let id = self
            .id
            .as_deref()
            .ok_or("Cannot verify commit: missing ID")?;
        let author_id = self
            .author_id
            .as_deref()
            .ok_or("Cannot verify commit: missing author_id")?;
        let signature = self
            .signature
            .as_deref()
            .ok_or("Cannot verify commit: missing signature")?;

        assert_eq!(
            author_id, author.id,
            "Tried to verify signature with wrong key"
        );

        let generated_id = {
            let mut idless_commit = self.clone();
            idless_commit.id = None;
            idless_commit.gen_id()
        };

        if id != generated_id {
            return Err(format!(
                "Badly generated commit ID. Expected {}, got {:?}",
                generated_id, id
            ))?;
        }

        let bytes = self.bytes();
        author.verify(&bytes, &signature)?;

        Ok(Commit {
            id: self.id.unwrap(),
            prev_commit_id: self.prev_commit_id,
            author_id: self.author_id.unwrap(),
            ts: self.ts,
            message: self.message,
            patch: self.patch,
            signature: self.signature.unwrap(),
            _priv: (),
        })
    }

    /// Create byte array with all commit data for signing (or ID generation when self.id is None)
    /// This method makes no assumptions on what fields are or **need** to be present.
    fn bytes(&self) -> Vec<u8> {
        let empty_string = String::new();
        let id_bytes = self
            .id
            .as_ref()
            .unwrap_or(&String::new())
            .as_bytes()
            .to_owned();
        let prev_commit_id_bytes = self
            .prev_commit_id
            .as_ref()
            .unwrap_or(&empty_string)
            .as_bytes();

        id_bytes
            .iter()
            .chain(prev_commit_id_bytes)
            .chain(self.author_id.as_ref().unwrap().as_bytes())
            .chain(self.ts.to_rfc3339().as_bytes())
            .chain(self.message.as_bytes())
            .chain(self.patch.as_bytes())
            .cloned()
            .collect()
    }

    /// Generate ID for current commit (does not change with already present ID or signature)
    fn gen_id(&self) -> String {
        debug_assert!(
            self.id.is_none(),
            "CommitData::gen_id() used with a non empty ID"
        );
        debug_assert!(
            self.author_id.is_some(),
            "CommitData::gen_id() used with empty author_id"
        );

        let bytes = self.bytes();
        let digest = digest::digest(ID_DIGEST_ALGO, &bytes);

        format!("{:x?}", digest)
    }
}

impl From<Commit> for UnsafeCommit {
    fn from(c: Commit) -> Self {
        UnsafeCommit {
            id: Some(c.id),
            prev_commit_id: c.prev_commit_id,
            author_id: Some(c.author_id),
            ts: c.ts,
            message: c.message,
            patch: c.patch,
            signature: Some(c.signature),
            _priv: (),
        }
    }
}

#[cfg(test)]
mod test {
    use toml;

    use super::*;
    use crate::test_utils::user::*;
    use crate::test_utils::commit::*;

    #[test]
    fn compatible_serialization() {
        let ucommit0_orig: UnsafeCommit = COMMIT_0.to_owned().into();
        let ucommit1_orig: UnsafeCommit = COMMIT_1.to_owned().into();

        let commit0_str = toml::to_string(&*COMMIT_0).unwrap();
        println!("{}", commit0_str);
        let commit1_str = toml::to_string(&*COMMIT_1).unwrap();

        let ucommit0: UnsafeCommit = toml::from_str(&commit0_str).unwrap();
        let ucommit1: UnsafeCommit = toml::from_str(&commit1_str).unwrap();

        assert_eq!(ucommit0_orig, ucommit0, "Incompatible serialization format (prev_commit_id=None)");
        assert_eq!(ucommit1_orig, ucommit1, "Incompatible serialization format (prev_commit_id!=None)");
    }

    #[test]
    fn verify_ok() {
        // de-verify
        let ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
        let ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();

        let commit0 = ucommit0.clone().verify(&*USER_A).unwrap();
        assert_eq!(ucommit0.id.unwrap(), commit0.id);
        assert_eq!(ucommit0.author_id.unwrap(), commit0.author_id);
        assert_eq!(ucommit0.ts, commit0.ts);
        assert_eq!(ucommit0.message, commit0.message);
        assert_eq!(ucommit0.patch, commit0.patch);
        assert_eq!(ucommit0.signature.unwrap(), commit0.signature);

        let commit1 = ucommit1.clone().verify(&*USER_B).unwrap();
        assert_eq!(ucommit1.id.unwrap(), commit1.id);
        assert_eq!(ucommit1.author_id.unwrap(), commit1.author_id);
        assert_eq!(ucommit1.ts, commit1.ts);
        assert_eq!(ucommit1.message, commit1.message);
        assert_eq!(ucommit1.patch, commit1.patch);
        assert_eq!(ucommit1.signature.unwrap(), commit1.signature);
    }

    #[test]
    fn author_ok() {
        let commit0 = UNAUTHORED_COMMIT_0.to_owned().author(&*USER_B).unwrap();
        assert_eq!(commit0.author_id, USER_B.id);
        assert_eq!(commit0.ts, UNAUTHORED_COMMIT_0.ts);
        assert_eq!(commit0.message, UNAUTHORED_COMMIT_0.message);
        assert_eq!(commit0.patch, UNAUTHORED_COMMIT_0.patch);

        let commit1 = UNAUTHORED_COMMIT_1.to_owned().author(&*USER_A).unwrap();
        assert_eq!(commit1.author_id, USER_A.id);
        assert_eq!(commit1.ts, UNAUTHORED_COMMIT_1.ts);
        assert_eq!(commit1.message, UNAUTHORED_COMMIT_1.message);
        assert_eq!(commit1.patch, UNAUTHORED_COMMIT_1.patch);
    }

    mod swap_field_fail_sig_tests {
        use std::mem;
        use crate::model::commit::UnsafeCommit;
        use crate::test_utils::commit::*;
        use crate::test_utils::user::*;

        macro_rules! test {
            ($field:ident) => {
                #[test]
                fn $field() {
                    let mut ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
                    let mut ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();
                    mem::swap(&mut ucommit0.$field, &mut ucommit1.$field);

                    assert!(ucommit0.verify(&*USER_A).is_err(), "verified commit with bad signature");
                    assert!(ucommit1.verify(&*USER_B).is_err(), "verified commit with bad signature");
                }
            };
        }

        test!(id);
        test!(prev_commit_id);
        //test!(author_id); // this is an outright panic
        test!(ts);
        test!(message);
        test!(patch);
        test!(signature);
    }

    #[test]
    #[should_panic(expected = "Tried to verify signature with wrong key")]
    fn verify_panic_author_mismatch() {
        let ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
        let ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();

        let _ = ucommit0.verify(&*USER_B); // should be B
        let _ = ucommit1.verify(&*USER_A); // should be A

        panic!("failed for the wrong reason. should have panicked before");
    }

    #[test]
    fn verify_err_missing_id() {
        let mut ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
        let mut ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();
        ucommit0.id = None;
        ucommit1.id = None;

        assert!(ucommit0.verify(&*USER_A).is_err(), "verified ID-less commit");
        assert!(ucommit1.verify(&*USER_B).is_err(), "verified ID-less commit");
    }

    #[test]
    fn verify_err_missing_author() {
        let mut ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
        let mut ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();
        ucommit0.author_id = None;
        ucommit1.author_id = None;

        assert!(ucommit0.verify(&*USER_A).is_err(), "verified author-less commit");
        assert!(ucommit1.verify(&*USER_B).is_err(), "verified author-less commit");
    }

    #[test]
    fn verify_err_missing_signature() {
        let mut ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
        let mut ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();
        ucommit0.signature = None;
        ucommit1.signature = None;

        assert!(ucommit0.verify(&*USER_A).is_err(), "verified signature-less commit");
        assert!(ucommit1.verify(&*USER_B).is_err(), "verified signature-less commit");
    }

    #[test]
    fn verify_err_empty_signature() {
        let mut ucommit0: UnsafeCommit = COMMIT_0.to_owned().into();
        let mut ucommit1: UnsafeCommit = COMMIT_1.to_owned().into();
        ucommit0.signature = Some(vec![]);
        ucommit1.signature = Some(vec![]);

        assert!(ucommit0.verify(&*USER_A).is_err(), "verified signature-less commit");
        assert!(ucommit1.verify(&*USER_B).is_err(), "verified signature-less commit");
    }

}
